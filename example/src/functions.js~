/**
 * @ngdoc module
 * @name app.api
 * @description The `app.api` module loads and exports support for the service APIs.
 */

'use strict';

const _ = require('lodash');
const ethu = require('ethereumjs-util');

function _scan_req(d, req) {
    let dl = d.split('.');
    let len = dl.length - 1;
    let curobj = req;
    let idx, obj;

    for (idx=0 ; idx < len ; idx++)
    {
	obj = curobj[dl[idx]];
	if (!_.isObject(obj)) return undefined;

	curobj = obj;
    }

    return curobj[dl[idx]];    
};

/**
 * @ngdoc function
 * @name pack_signature_data
 * @module app.api
 * @description Pack the signature data from a request parameters and API signature descriptor.
 *  This function iterates over the elements of *desc*, looks up the correpsonding property in *req*,
 *  and appends it to a JSON-like representation of the signature data.
 *
 *  The representation is JSON-like in that all properties are flattened out instead of being emitted
 *  within their containers. For example, a *desc* element named `params.foo.bar` looks up the **bar**
 *  property in the **foo** property of the **params** property of *req*, and emits it as a flat key/value
 *  pair whise key is **params.foo.bar**. Additionally, object and array values are not allowed.
 *
 * @param {Object} req An object that contains the request parameters.
 * @param {Array} desc An array of string values, each a possibly nested property of *req*.
 *
 * @return {String} Returns a string containing the JSON representation of the request parameters listed
 *  in *desc*.
 */

function _pack_signature_data(req, desc) {
    let rep = _.map(desc, function(d, idx) {
	return '"' + d + '":' + JSON.stringify(_scan_req(d, req));
    });

    return '{' + rep.join(',') + '}';
};

/**
 * @ngdoc function
 * @name sign_request_data
 * @module app.api
 * @description Pack and sign request data.
 *  This function calls {@sref app.api#pack_signature_data} to generate the signature data, then creates
 *  the keccak (SHA3) hash of the data, and signs it with the private key in *pkey*.
 *  The signature is placed in the **signature** property of *req*.
 *
 * @param {Object} req An object that contains the request parameters.
 * @param {Array|Boolean} desc An array of string values, listing the request parameters to pack.
 *  Or any other value (`false` by convention) to indicate that no signature should be calculated.
 * @param {String|Buffer} pkey The private key to use; if passed as a string, it must be a hex
 *  representation of the private key, with an optional `0x` prefix.
 *
 * @return {Object} Returns the signature, as an object containing the properties **v**, **r**, and **s**;
 *  if *desc* is not an array, returns `undefined`.
 */

function _sign_request_data(req, desc, pkey) {
    if (!_.isArray(desc)) return undefined;
    
    req.signature = ethu.ecsign(ethu.keccak(_pack_signature_data(req, desc)), ethu.toBuffer(pkey));
    return req.signature;
};

/**
 * @ngdoc function
 * @name stringify_signature
 * @module app.api
 * @description Convert the contents of a signature object to hex strings.
 *  This function converts the **r** and **s** properties of *sig* to hex strings with a `0x` prefix.
 *
 * @param {Object} sig The rignature, as an object containing the properties **v**, **r**, and **s**;
 *  the latter two may be stored as Buffer types.
 *
 * @return {Object} Returns the signature, as an object containing the properties **v**, **r**, and **s**,
 *  where the latter two have been converted to hex strings.
 */

function _stringify_signature(sig) {
    return {
	v: sig.v,
	r: _.isString(sig.r) ? sig.r : ethu.baToJSON(sig.r),
	s: _.isString(sig.s) ? sig.s : ethu.baToJSON(sig.s)
    };
};

/**
 * @ngdoc function
 * @name bufferize_signature
 * @module app.api
 * @description Convert the contents of a signature object to Buffer instances.
 *  This function converts the **r** and **s** properties of *sig* to Buffer instances, and the **v** property
 *  to an integer.
 *
 * @param {Object} sig The rignature, as an object containing the properties **v**, **r**, and **s**;
 *  the latter two may be stored as hex strings.
 *
 * @return {Object} Returns the signature, as an object containing the properties **v**, **r**, and **s**,
 *  where the latter two have been converted to Buffer instances.
 */

function _bufferize_signature(sig) {
    return {
	v: (Buffer.isBuffer(sig.v)) ? ethu.bufferToInt(sig.v) : _.toInteger(sig.v),
	r: ethu.toBuffer(sig.r),
	s: ethu.toBuffer(sig.s)
    };
};

/**
 * @ngdoc function
 * @name recover_signed_request_data
 * @module app.api
 * @description Recover the public key from request data and signature.
 *  This function calls {@sref app.api#pack_signature_data} to generate the signature data, then generates
 *  the keccak (SHA3) hash of the data, and
 *  recovers the public key corresponding to the signature in **req.signature**, or to the given signature.
 *
 * @param {Object} req An object that contains the request parameters.
 * @param {Array} desc An array of string values, listing the request parameters to pack.
 * @param {Object} signature The signature, as an object containing the properties **v**, **r**, and **s**.
 *  If this argument is not provided, the function attempts to use the **req.signature** property.
 *
 * @return {String} Returns a string containing the hex representation of the public key.
 *  If no signature is available, returns `undefined`.
 *
 * @throws {Error} Throws an exception in case of error; typically from the Ethereum-js code.
 */

function _recover_signed_request_data(req, desc, signature) {
    if (_.isNil(signature)) signature = req.signature;
    if (_.isNil(signature)) return undefined;

    let sig = _bufferize_signature(signature);
    let hash = ethu.keccak(_pack_signature_data(req, desc));
    return '0x' + ethu.ecrecover(hash, sig.v, sig.r, sig.s).toString('hex');
};

/**
 * @ngdoc function
 * @name address_from_signed_request_data
 * @module app.api
 * @description Recover the Ethereum address from request data and signature.
 *  This function calls {@sref app.api#pack_signature_data} to generate the signature data, then generates
 *  the keccak (SHA3) hash of the data, and
 *  recovers the public key corresponding to the given signature. It then returns the Ethereum address
 *  corresponding to the public key.
 *
 * @param {Object} req An object that contains the request parameters.
 * @param {Array} desc An array of string values, listing the request parameters to pack.
 * @param {Object} signature The signature, as an object containing the properties **v**, **r**, and **s**.
 *  If this argument is not provided, the function attempts to use the `req.signature` property.
 *
 * @return {String} Returns a string containing the hex representation of the Ethereum address.
 *
 * @throws {Error} Throws an exception in case of error; typically from the Ethereum-js code.
 */

function _address_from_signed_request_data(req, desc, signature) {
    if (_.isNil(signature)) signature = req.signature;
    if (_.isNil(signature)) return undefined;
    
    let sig = _bufferize_signature(signature);
    let hash = ethu.keccak(_pack_signature_data(req, desc));
    return '0x' + ethu.pubToAddress(ethu.ecrecover(hash, sig.v, sig.r, sig.s)).toString('hex');
};

/**
 * @ngdoc function
 * @name validate_signed_request_data
 * @module app.api
 * @description Validate signed request data by checking that it was signed by the same address as
 *  listed in the **signer** property.
 *  This function calls {@sref app.api#pack_signature_data} to generate the signature data, then generates
 *  the keccak (SHA3) hash of the data, and
 *  recovers the public key corresponding to the given signature, and from it the Ethereum address
 *  corresponding to the public key. It then compares that address to the **signer** property of *req*
 *  and returns true if they are the same.
 *
 * @param {Object} req An object that contains the request parameters.
 * @param {Array} desc An array of string values, listing the request parameters to pack.
 * @param {Object} signature The signature, as an object containing the properties **v**, **r**, and **s**.
 *  If this argument is not provided, the function attempts to use the `req.signature` property.
 *
 * @return {Boolean} Returns `true` if the request was signed by `req.signer`, `false` otherwise
 *  (including is **signer** is not present in *req*).
 */

function _validate_signed_request_data(req, desc, signature) {
    if (_.isNil(req.signer)) return false;
    
    let addr = _address_from_signed_request_data(req, desc, signature);

    return (addr.toLowerCase() == ethu.addHexPrefix(req.signer).toLowerCase());
};

/**
 * @ngdoc function
 * @name build_descriptor
 * @module app.api
 * @description Builds an API descriptor.
 *
 * @param {Object} desc Common descriptor properties.
 * @property {String} desc.root The root of the API URL.
 * @property {Object} desc.defaults Default properties to apply to the descriptors; any properties by
 *  the same name in the descriptors override the default value.
 * @param {Object} actions An object containing the descriptors for the actions implemented by the API.
 *  The keys are action names, and the values are objects that contain the action descriptors:
 *  - **method** The HTTP method (`GET`, `POST`, *etc...*).
 *  - **path** The path, rooted at the global root: for example, the path for `/the/root/show/:id`
 *    is `/show/:id`.
 *  - **sign** Describes if the API requires a signature. This is an object that contains the two
 *    properties **request** and **response**. If the value is an array, it is a list of properties to add to
 *    the signed data. For a request, these properties are scoped in the request data; for a response,
 *    they are scoped from the contents of the response's **result** property.
 *    Any other value of the property (by convention, `false`) indicates that no signature is required.
 *    A missing property's vaue default to `false`.
 *  - **nonce** Does the caller need to provide a nonce? If `true`, the API call must provide a
 *    **nonce** property in the request parameters.
 *
 * @return {Object} Returns an object containing the following properties:
 *  - **root** A string containing the API root.
 *  - **actions** An object containing the entry point descriptors. The keys are action names, the values
 *    objects as described above.
 */

function _build_descriptor(desc, actions) {
    let defaults = _.assign({
	sign: { request: false, response: false }
    }, (_.isObject(desc.defaults)) ? desc.defaults : { });
    let al = _.reduce(actions, function(rv, e, k) {
	rv[k] = _.assign({ }, defaults, e);
	return rv;
    }, { });

    return { root: desc.root, actions: al };
};

/**
 * @ngdoc function
 * @name success
 * @module app.api
 * @description Builds a succesful return value.
 *
 * @param {Mixed} value The return value.
 *
 * @return {Object} Returns an object containing the following properties:
 *  - **status** The status of the call; this property's value is the string `ok`.
 *  - **result** The result value; the property's value is the *value* parameter.
 */

function _success(value) {
    return { status: 'ok', result: value };
};

/**
 * @ngdoc function
 * @name error
 * @module app.api
 * @description Builds an error return value.
 *
 * @param {String} code The error "code:" a string containing an identifier for the error.
 *  A common pattern is to use the name of the file where the error occurred, and a numeric value,
 *  like `app/api.js:0010`.
 * @param {String} msg A message associated with the error.
 * @param {Object} details An object containing error details (if present).
 *
 * @return {Object} Returns an object containing the following properties:
 *  - **status** The status of the call; this property's value is the string `error`.
 *  - **error** Is an object containing error information:
 *    - **code** The error code, as passed to *code*.
 *    - **message** The error message, as passed to *msg*.
 *    - **details** If *details* is provided, this property is present and contains its value.
 */

function _error(code, msg, details) {
    let rv = { status: 'error', error: { code: code, message: msg } };
    if (!_.isNil(details)) rv.error.details = details;

    return rv;
};

/**
 * @ngdoc function
 * @name signature_required
 * @module app.api
 * @description Sets the status code to 401 and adds the `WWW-Authenticate` header to specify the (bogus)
 *  `X-CG-Signature` type.
 *  This is done so that the response is consistent with the HTTP 401 status code's specification,
 *  which requires that this header be sent.
 *
 * @param {Express.Response} res The Express response object to modify.
 * @param {String} realm If defined, this will be the value of the **realm** component.
 *
 * @return {Express.Response} Returns *res*.
 */

function _signature_required(res, realm) {
    let h = 'X-CG-Signature';
    if (!_.isNil(realm)) h += ' realm="' + realm + '"';
    
    return res.status(401).set('WWW-Authenticate', h);
};

/**
 * @ngdoc function
 * @name check_param
 * @module app.api
 * @description Finds a parameter's value from a parameter set.
 *
 * @param {String} name The parameter name; this can be expressed as a hierarchical name to indicate that
 *  the parameter is nested inside objects. For example, **_q.order** attempts to find the **order** property
 *  of the **_q** property of *pars*.
 * @param {Object} pars The parameter set to search.
 *
 * @return {Mixed} Returns the value of the *name* property, `undefined` if it was not found.
 */

function _check_param(name, pars) {
    if (!_.isObject(pars)) return undefined;

    let nl = _.map(name.split('.'), function(v, idx) { return v.trim(); });
    let cur = pars;
    let idx, k;
    let len = nl.length - 1;
    
    for (idx=0 ; idx < len ; idx++)
    {
	k = nl[idx];
	if (!_.isObject(cur[k])) return undefined;
	cur = cur[k];
    }

    k = nl[len];
    
    return cur[k];
};

module.exports = {
    pack_signature_data: _pack_signature_data,
    sign_request_data: _sign_request_data,
    stringify_signature: _stringify_signature,
    bufferize_signature: _bufferize_signature,
    recover_signed_request_data: _recover_signed_request_data,
    address_from_signed_request_data: _address_from_signed_request_data,
    validate_signed_request_data: _validate_signed_request_data,
    build_descriptor: _build_descriptor,
    success: _success,
    error: _error,
    signature_required: _signature_required,
    check_param: _check_param
};
